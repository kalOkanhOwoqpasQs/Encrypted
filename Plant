math.randomseed(os.time() + os.clock() * 100000)
local bot = getBot()
local bots = #getBots()

local farmList = {}
local farmWorld = {}
local storageSeed = {}
local storageSplice = {}
local storageSpray = {}

local farmInfo = {}
local timeInfo = {}

local originalSeed = {}
local originalSplice = {}
local originalSpray = {}

local initialize = {}
local tileYList = {}
local messageID = {}
local item = {plantID.seed}

local worldFarm
local worldSeed
local worldSplice
local worldSpray
local singleID = 0
local messageIdInfo = 0

local nuked = false
local wrong = false

local scriptUpTime = os.time()
local indexBot = 0
local avatarUrl = 'https://cdn.discordapp.com/attachments/1137217694589001859/1318778973739679774/Handwritten_Love_Poster_in_White_Black_Background_20241218_101600_0000.png?ex=67639021&is=67623ea1&hm=109cfe9dac9edf4416c9ac6cd695a2725553c35ecec0d43f5561016ab3b5f9b8&'

local files = {
    NUKED = '[PLANT] NUKED LIST.txt',
    WRONG = '[PLANT] WRONG LIST.txt',
    VIEW = '[PLANT] BOT VIEW.txt'
}

bot.legit_mode = false
bot.auto_reconnect = true
bot.reconnect_interval = delayReconnect
bot.random_reconnect = false
bot.auto_collect = false

local function writeFile(content, fileName)
    local file = io.open(fileName, 'a+')
    if file then
        file:write(content .. '\n')
        file:close()
    end
end

local function fileExists(fileName)
    local file = io.open(fileName, "r")
    if file then
        file:close()
        return true
    else
        return false
    end
end

local function deleteFile(fileName)
    local result, reason = os.remove(fileName)
    if result then
        print(fileName .. " was deleted successfully.")
    else
        print("Error deleting " .. fileName .. ": " .. reason)
    end                                                                                                             
end

local function readFile(fileName)
    local tbl = {}
    local file = io.open(fileName, 'r')
    if file then
        for line in file:lines() do
            table.insert(tbl, line)
        end
        file:close()
        return tbl
    else
        return error('Failed to open file : ' .. fileName)
    end
end

local function assignWorld(var)
    local result
    if var.useFile.enabled then
        result = var.useFile.filePath
    else
        result = var.world
    end
    return result
end

local function selectWorld(enable, world, tbl)
    if enable.enabled then
        local assign = readFile(world)
        if assign then
            for i, worlds in ipairs(assign) do
                table.insert(tbl, worlds)
            end
        end
    else
        for i, worlds in ipairs(world) do
            table.insert(tbl, worlds)
        end
    end
end

local function round(num)
    return num % 1 > 0.5 and math.ceil(num) or math.floor(num)
end

local function writeConsole(description)
    return bot:getLog():append(description)
end

local function backpack(id)
    return bot:getInventory():getItemCount(id)
end

local function checkItem(enableState)
    if enableState then
        return (plantID.splice ~= 0 and backpack(plantID.seed) >= 5 and backpack(plantID.splice) >= 5) or (plantID.splice == 0 and backpack(plantID.seed) >= 5)
    else
        return (plantID.spray ~= 0 and backpack(plantID.spray) >= 5) or (plantID.spray == 0)
    end
end

local function isCanFindpath(x, y)
    return (#bot:getPath(x, y) > 0 or bot:isInTile(x, y))
end

local function createMessageID(url, content, fileNames)
    if url ~= '' then
        url = url .. '?wait=1'
        local http = HttpClient.new()
        http.url = url
        http.headers['Content-Type'] = 'application/json'
        http:setMethod(Method.post)
        http.content = [[
        {
            "username":"CRUS4DER",
            "embeds": [
                {
                    "title":"]] .. content .. [[",
                    "color": ]] .. math.random(111111, 999999) .. [[
                }
            ]
        }
    ]]
        local result = http:request()
        if result.error == 0 then
            local resultData = result.body:match('"id"%s*:%s*"([^"]+)"')
            if resultData and fileNames then
                writeFile(resultData, fileNames)
            end
            return resultData
        else
            print("Request Error: " .. result:getError())
        end
        return nil
    end
    return nil
end

local function createWebhook(botIndex, totalBots)
    if linkBotView ~= 'x' then
        local whCount = math.ceil(totalBots / maxBotPerWebhook)
        for i = 1, whCount do
            local startBot = (i - 1) * maxBotPerWebhook + 1
            local endBot = math.min(i * maxBotPerWebhook, totalBots)
            if botIndex == startBot then
                local messageIDs = createMessageID(linkBotView, 'Creating message for Bot List', files.VIEW)
            end
        end
        local readID = readFile(files.VIEW)
        for i , msg in pairs(readID) do
            table.insert(messageID, msg)
        end
        messageIdInfo = messageID[math.floor((bot.index - 1) / maxBotPerWebhook) + 1]
    end
end

local function itemFloat(id)
    return getWorld().growscan:getObjects()[id] or 0
end

local function scanItem(enableState)
    if enableState then
        if storage.differentSplice.enabled then
            return itemFloat(plantID.seed) >= 5
        else
            return (plantID.splice == 0 and itemFloat(plantID.seed) >= 5) or
                   (plantID.splice ~= 0 and itemFloat(plantID.seed) >= 5 and itemFloat(plantID.splice) >= 5)
        end
    else
        if storage.differentSpray.enabled then
            return true
        else
            return (plantID.spray ~= 0 and not storage.differentSpray.enabled and itemFloat(plantID.spray) >= 5) or
                   (plantID.spray == 0)
        end
    end
end

local function notifications(description)
    messageBox = MessageBox.new()
    messageBox.title = 'CRUS4DER | Script Store'
    messageBox.description = description
    messageBox:send()
end

local function split(str, ptr)
    if not ptr then
        ptr = '%s'
    end
    local tbl = {}
    for string in string.gmatch(str, ptr) do
        table.insert(tbl, string)
    end
    return tbl
end

local function spreadWorld(tbl, target)
    local totalWorlds = tbl
    local totalBots = #getBots()
    local index = bot.index - 1
    local split = #totalWorlds / totalBots
    local start = math.floor(index * split) + 1
    local stop = math.floor((index + 1) * split)
    for i = start, stop do
        table.insert(target, totalWorlds[i])
    end
end

local function assignBot(data, limit, save)
    limit = limit or 1
    local worlds = data
    local start = math.floor((bot.index - 1) / limit) + 1
    local range = math.ceil(#getBots() / limit)
    for index = start, #worlds, range do
        if worlds[index] then
            table.insert(save, worlds[index])
        end
    end
    return save
end

local function getIndex()
    local tbl = {}
    local a = math.floor((bot.index - 1) / worldList.botPerWorld) + 1
    for i, bot in pairs(getBots()) do
        if a == (math.floor((bot.index - 1) / worldList.botPerWorld) + 1) then
            table.insert(tbl, bot.name)
        end
    end
    for i, name in pairs(tbl) do
        if bot.name == name then
            return i
        end
    end
    return 0
end

local function formatStatus(plr)
    for i, v in pairs(BotStatus) do
        if v == plr.status then
            return tostring(i:gsub("_", " "):gsub("^%l", string.upper))
        end
    end
    return "Unknown"
end

local function emojiRecon(plr)
    if plr.status == BotStatus.online then
        return "<a:online:1235638419284037763>"
    end
    return "<a:offline:1238731608220237845>"
end

local function formatSeconds(seconds)
    local days = math.floor(seconds / (24 * 3600))
    local remainingSeconds = seconds % (24 * 3600)
    local hours = math.floor(remainingSeconds / 3600)
    local minutes = math.floor((remainingSeconds % 3600) / 60)
    return string.format("%d Days %d Hours %d Minutes", days, hours, minutes)
end

local function formatUptimeFarm(seconds)
    local minutes = math.floor((seconds % 3600) / 60)
    return string.format("%d Mins", minutes)
end

local function database(case)
    local str = ''
    local function processStorage(storage, itemID, message)
        if itemID ~= 0 then
            if #storage == 0 then
                return 'No storage available'
            else
                for i = 1, #storage do
                    local name = split(storage[i], '[^:]+')[1]
                    str = str .. '\n**[||' .. name .. '||]** '..(initialize[name] or 'N/A')
                end
                return str
            end
        else 
            return message 
        end
    end
    if case == 'seed' then
        return processStorage(storageSeed, plantID.seed, '')
    elseif case == 'splice' then
        return processStorage(storageSplice, plantID.splice, 'Splice are disable.')
    elseif case == 'spray' then
        return processStorage(storageSpray, plantID.spray, 'Spray are disable.')
    end
    return str
end

local function worldEstimate()
    local estimate = ''
    for _, world in pairs(farmInfo) do
        estimate = estimate .. '\n<:Globe:1179469791086530681>||' ..world ..'|| ('..(timeInfo[world] and (type(timeInfo[world]) == 'number' and '<a:on:1235638419284037763>' .. formatUptimeFarm(os.difftime(os.time(), timeInfo[world])) or '<a:off:1235638416821981316>' .. timeInfo[world]) or '<a:off:1235638416821981316>N/A') ..')'
    end
    return estimate
end

local function scanSeedID()
    if linkWorldInfo ~= 'x' then
        local growscan = getBot():getWorld().growscan
        local str = ''
        for _, v in pairs(item) do
            for id, count in pairs(growscan:getObjects()) do
                if id == v then
                    str = str .. "\n" .. getInfo(id).name .. " : " .. count .. 'x'
                end
            end
        end
        return str
    end
end

local function botStatic(message)
    if linkBotView ~= 'x' then
        local webhook = Webhook.new(linkBotView)
        webhook.avatar_url = avatarUrl
        webhook.username = "CRUS4DER"
        webhook.embed1.use = true
        webhook.embed1.color = math.random(111111, 999999)
        webhook.embed1.title = "Bots View"
        webhook.embed1.thumbnail = avatarUrl
        webhook.embed1.description = "**Updated: <t:" .. os.time() .. ":R>\nTotal Bot : "..bots.."\nScript : Auto Plant\nUptime : "..formatSeconds(os.difftime(os.time(), scriptUpTime)).."\nSended By : "..bot.name.."**"
        local startBot = ((math.ceil(bot.index / maxBotPerWebhook) - 1) * maxBotPerWebhook) + 1
        local endBot = startBot + maxBotPerWebhook - 1
        for _, name in pairs(getBots()) do
            if name.index >= startBot and name.index <= endBot then
                webhook.embed1:addField('['..name.index..']'..name.name, 'Task : '..name.custom_status..'\nLevel : '..name.level..'\nWorld : ||'..name:getWorld().name..'||\nStatus : '..emojiRecon(name)..''..formatStatus(name)..'', true)
            end
        end
        webhook.embed1.footer.icon_url = avatarUrl
        webhook.embed1.footer.text = 'Script developed By CRUS4DER'
        webhook.embed1.timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
        webhook:edit(message)
    end
end

local function botInfo(message)
    if linkWorldInfo ~= 'x' then
        local webhook = Webhook.new(linkWorldInfo)
        webhook.username = "CRUS4DER"
        webhook.avatar_url = avatarUrl
        webhook.embed1.use = true
        webhook.embed2.use = true
        webhook.embed1.thumbnail = avatarUrl
        webhook.embed1.color = math.random(111111, 999999)
        webhook.embed1.title = 'Slot - ' .. bot.index .. ' | CRUS4DER'
        webhook.embed1:addField('<:smallseedpack:1233810600703033374>Storage Seed', database('seed'), true)
        webhook.embed1:addField('<:smallseedpack:1233810600703033374>Storage Splice', database('splice'), true)
        webhook.embed1:addField('<:smallseedpack:1233810600703033374>Storage Spray', database('spray'), true)
        webhook.embed2:addField('<:scrollbulletin:1228977435668910151>Farm Estimates', worldEstimate(), true)
        webhook.embed2.footer.icon_url = avatarUrl
        webhook.embed2.footer.text = 'Updated : ' .. (os.date('!%a, %b %d %Y at %I:%M %p', os.time() + 7 * 60 * 60)) .. '.\nScript developed By CRUS4DER'
        webhook:edit(message)
    end
end

local function botSend(text)
    if webhookStatusLink ~= 'x'  then
        local webhook = Webhook.new(webhookStatusLink)
        if tagDiscord then
            webhook.content = '@everyone'
        end
        webhook.username = "CRUS4DER"
        webhook.embed1.use = true
        webhook.embed1:addField('BOT INFORMATION', bot.name.. ' slot-' .. bot.index .. ' : **'..text..'**', false)
        webhook.embed1.footer.text = 'Updated : '..(os.date('!%a %b %d, %Y at %I:%M %p', os.time() + 7 * 60 * 60))..''
        webhook.embed1.footer.icon_url = avatarUrl
        webhook:send()
    end
end

local function reconnect()
    if bot.status ~= BotStatus.online then
        writeConsole(bot.name.. ' (slot-' .. bot.index .. ') status is ' .. formatStatus(bot))
        botSend('status is ' .. formatStatus(bot).. ''..emojiRecon(bot))
        botStatic(messageIdInfo)
        while bot.status ~= BotStatus.online do
            sleep(10000)
            if bot.status == BotStatus.account_banned or bot.status == BotStatus.account_suspended then
                bot.auto_reconnect = false
                writeConsole(bot.name.. ' (slot-' .. bot.index .. ') status is ' .. formatStatus(bot))
                botSend('status is ' .. formatStatus(bot).. ''..emojiRecon(bot))
                return error('Bot Suspended')
            elseif bot.status == BotStatus.maintenance then
                bot.auto_reconnect = false
                writeConsole(bot.name.. ' (slot-' .. bot.index .. ') status is ' .. formatStatus(bot))
                botSend('status is ' .. formatStatus(bot).. ''..emojiRecon(bot))
                sleep(60000 * delayMaintenance)
                bot.auto_reconnect = true
            end
        end
        writeConsole(bot.name.. ' (slot-' .. bot.index .. ') status is ' .. formatStatus(bot))
        botSend('status is ' .. formatStatus(bot).. ''..emojiRecon(bot))
        botStatic(messageIdInfo)
    end
end

local function warp(world, id)
    world = world:upper()
    id = id or ''
    nuked, wrong = false, false
    if not bot:isInWorld(world) then
        addEvent(Event.variantlist, function(variant, netid)
            if variant:get(0):getString() == 'OnConsoleMessage' then
                if variant:get(1):getString():lower():find('inaccessible.') then
                    nuked = true
                    unlistenEvents()
                end
            end
        end)
        local tries = 0
        while not bot:isInWorld(world) and not nuked do
            reconnect()
            bot:sendPacket(3, "action|join_request\nname|" .. (id == '' and world or world .. ('|' .. id)) .. "\ninvitedWorld|0")
            for i = 1, delayWarp do
                listenEvents(1)
                if bot:isInWorld(world) or nuked then
                    break
                end
            end
            sleep(5000)
            tries = tries + 1
            if tries % 8 == 0 then
                writeConsole('Hard warp? resting bot for '..delayHardWarp..' minutes')
                bot.auto_reconnect = false
                bot.custom_status = 'Hard Warp'
                while bot.status == BotStatus.online do
                    bot:disconnect()
                    sleep(5000)
                end
                sleep(60000 * delayHardWarp)
                bot.custom_status = 'Planting'
                bot.auto_reconnect = true
            end
        end
        removeEvent(Event.variantlist)
    end
    if bot:isInWorld(world) and id ~= '' then
        local tries = 0
        while getTile(bot.x, bot.y).fg == 6 and not wrong do
            reconnect()
            bot:warp(id == '' and world or world .. ('|' .. id))
            for i = 1, delayWarp do
                sleep(1000)
                if getTile(bot.x, bot.y).fg ~= 6 then
                    break
                end
            end
            sleep(3000)
            tries = tries + 1
            if tries % 5 == 0 then
                wrong = true
            end
        end
    end
end

local function reposition(world, id, x, y)
    if bot.status ~= BotStatus.online then
        reconnect()
    end
    if bot.status == BotStatus.online then
        warp(world, id)
        if (x and y) and (bot:isInWorld(world) and isCanFindpath(x, y)) then
            while not bot:isInTile(x, y) do
                bot:findPath(x, y)
                reposition(world, id)
            end
        end
    end
end

local function customTiles()
    local tiles = {}
    if worldList.botPerWorld == 1 then
        for y = 0, 53 do
            if (y % 4 == 1) then
                for x = 0, 99 do
                    table.insert(tiles, { x = x, y = y })
                end
            else
                for x = 99, 1, -1 do
                    table.insert(tiles, { x = x, y = y })
                end
            end
        end
    else
        for i, y in pairs(tileYList) do
            if indexBot == ((i - 1) % worldList.botPerWorld) + 1  then
                for x = 0, 99 do
                    table.insert(tiles, { x = x, y = y })
                end
            end
        end
    end
    return tiles
end

local function isPlantable(x, y, enabled)
    local tile1 = getTile(x, y)
    local tile2 = getTile(x, y + 1)
    if not bot:isInWorld() then return false end
    if not tile1.fg then return false end
    if not tile2.fg then return false end
    local collision = getInfo(tile2.fg).collision_type
    return (enabled and tile1.fg == 0 and tile2.fg ~= 0 and isCanFindpath(x, y) and hasAccess(x, y) > 0 and (collision ~= 0 and collision <= 3)) or
           (not enabled and (tile1.fg == plantID.seed or tile1.fg == 0 or tile1.fg == plantID.splice) and tile2.fg ~= 0 and isCanFindpath(x, y) and hasAccess(x, y) > 0 and (collision ~= 0 and collision <= 3))
end

local function canSpray(x, y)
    local tile1 = getTile(x, y)
    if not bot:isInWorld() then return false end
    if not tile1.fg then return false end
    return (not tile1:canHarvest() and isCanFindpath(x, y) and hasAccess(x, y) > 0)
end

local function shuffle(tbl)
    for i = #tbl, 2, -1 do
        local j = math.random(i)
        tbl[i], tbl[j] = tbl[j], tbl[i]
    end
    return tbl
end

local function scanTiles()
    local count = 0
    for _, tile in pairs(customTiles()) do
        if isPlantable(tile.x, tile.y, true) then
            count = count + 1
        end
    end
    return count
end

local function tilecache(x, y, num)
    local count = 0
    local stack = 0
    for _, obj in pairs(getObjects()) do
        local object_x, object_y = math.floor((obj.x + 10) * (1 / 32)), math.floor((obj.y + 10) * (1 / 32))
        if object_x == x and object_y == y then
            stack = stack + 1
            count = count + obj.count
        end
    end
    return stack < 20 and count <= (4000 - num)
end

local function storeItem(storage, unPack, items)
    ::back::
    if #storage == 0 then
        world = {table.unpack(unPack)}
        goto back
    end
    bot.custom_status = 'Restore items'
    local index = math.random(#storage)
    local world, door = split(storage[index], '[^:]+')[1], split(storage[index], '[^:]+')[2]
    if not nuked then
        if not wrong then
            botStatic(messageIdInfo)
            if worldList.botPerWorld ~= 1 then
                worldList.botPerWorld = 1
            end
            local tiles = shuffle(customTiles())
            local foundPath = true
            while foundPath do
                for i, v in ipairs(items) do
                    for _, tile in pairs(tiles) do
                        while not bot:isInTile(tile.x, tile.y) and isCanFindpath(tile.x, tile.y) do
                            bot:findPath(tile.x, tile.y)
                            reposition(world, door, tile.x, tile.y)
                        end
                        if getTile(tile.x + 1, tile.y).fg == 0 and tilecache(tile.x + 1, tile.y, backpack(v)) then
                            while backpack(v) > 0 and tilecache(tile.x + 1, tile.y, backpack(v)) do
                                bot:setDirection(false)
                                bot:drop(v, backpack(v))
                                sleep(2000)
                                reposition(world, door, tile.x, tile.y)
                            end
                        end
                        tiles = shuffle(customTiles(1, 50))
                        if backpack(v) == 0 then
                            foundPath = false
                            break
                        end
                    end
                end
            end
        else
            writeFile(world..' ---STORAGE RESTORE', files.WRONG)
            writeConsole('['..world..'] Storage restore has wrong ID, removing worlds')
            table.remove(storage, index)
            goto back
        end
    else
        writeFile(world..' ---STORAGE RESTORE', files.NUKED)
        writeConsole('['..world..'] Storage restore has NUKED, removing worlds')
        table.remove(storage, index)
        goto back
    end
end

local function restore()
    if not storage.differentSplice.enabled and not storage.differentSpray.enabled then
        storeItem(storageSeed, originalSeed, item)
    else
        item = {plantID.seed}
        storeItem(storageSeed, originalSeed, item)
    end
    if storage.differentSplice.enabled then
        item = {plantID.splice}
        storeItem(storageSplice, originalSplice, item)
    end
    if storage.differentSpray.enabled then
        item = {plantID.spray}
        storeItem(storageSpray, originalSpray, item)
    end
end

local function takeSplice()
    ::back::
    if #storageSplice == 0 then
        if looping then
            storageSplice = {table.unpack(originalSplice)}
            goto back
        else
            restore()
            bot.custom_status = 'Storage splice has empty'
            botInfo(singleID)
            bot:leaveWorld()
            botStatic(messageIdInfo)
            local dialog = 'No world available for collecting seed splice'
            writeConsole(dialog)
            botSend(dialog)
            if removingBots then
                removeBot()
            end
            if sendNotif then
                notifications(dialog)
            end
            return error(dialog)
        end
    end
    bot.custom_status = 'Take seed splice'
    local index = math.random(#storageSplice)
    local world, door = split(storageSplice[index], '[^:]+')[1], split(storageSplice[index], '[^:]+')[2]
    warp(world, door)
    if not nuked then
        if not wrong then
            botStatic(messageIdInfo)
            table.insert(originalSplice, storageSplice[index])
            if itemFloat(plantID.splice) >= 5 then
                while backpack(plantID.splice) < 200 do
                    local pathFound = false
                    for _, obj in pairs(getObjects()) do
                        local targetX, targetY = round(obj.x / 32), math.floor(obj.y / 32)
                        local canFindpath = isCanFindpath(targetX, targetY)
                        if obj.id == plantID.splice and canFindpath then
                            bot:findPath(targetX, targetY)
                            sleep(500)
                            bot:collectObject(obj.oid, 3)
                            sleep(500)
                            reposition(world, door, targetX, targetY)
                            pathFound = true
                            break
                        end
                    end
                    if not pathFound then
                        break
                    end
                end
            else
                if not looping then
                    writeConsole('['..world..'] seed splice has empty, removing worlds')
                    botSend('['..world..'] seed splice has empty, removing worlds')
                else
                    while bot:isInWorld() do
                        bot:leaveWorld()
                        sleep(5000)
                    end
                    sleep(1000 * delayLooping)
                end
                table.remove(storageSplice, index)
                goto back
            end
            initialize[world] = scanSeedID()
            botInfo(singleID)
        else
            writeFile(world..' ---STORAGE SEED SPLICE', files.WRONG)
            writeConsole('['..world..'] Storage seed splice has wrong ID, removing worlds')
            table.remove(storageSplice, index)
            goto back
        end
    else
        writeFile(world..' ---STORAGE SEED SPLICE', files.NUKED)
        writeConsole('['..world..'] Storage seed splice has NUKED, removing worlds')
        table.remove(storageSplice, index)
        goto back
    end
end

local function takeSpray()
    ::back::
    if #storageSpray == 0 then
        if looping then
            storageSpray = {table.unpack(originalSpray)}
            goto back
        else
            restore()
            bot.custom_status = 'Storage spray has empty'
            botInfo(singleID)
            bot:leaveWorld()
            botStatic(messageIdInfo)
            local dialog = 'No world available for collecting spray'
            writeConsole(dialog)
            botSend(dialog)
            if removingBots then
                removeBot()
            end
            if sendNotif then
                notifications(dialog)
            end
            return error(dialog)
        end
    end
    bot.custom_status = 'Take spray'
    local index = math.random(#storageSpray)
    local world, door = split(storageSpray[index], '[^:]+')[1], split(storageSpray[index], '[^:]+')[2]
    warp(world, door)
    if not nuked then
        if not wrong then
            botStatic(messageIdInfo)
            table.insert(originalSpray, storageSpray[index])
            if itemFloat(plantID.spray) >= 5 then
                while backpack(plantID.spray) < 200 do
                    local pathFound = false
                    for _, obj in pairs(getObjects()) do
                        local targetX, targetY = round(obj.x / 32), math.floor(obj.y / 32)
                        local canFindpath = isCanFindpath(targetX, targetY)
                        if obj.id == plantID.spray and canFindpath then
                            bot:findPath(targetX, targetY)
                            sleep(500)
                            bot:collectObject(obj.oid, 3)
                            sleep(500)
                            reposition(world, door, targetX, targetY)
                            pathFound = true
                            break
                        end
                    end
                    if not pathFound then
                        break
                    end
                end
            else
                if not looping then
                    writeConsole('['..world..'] spray has empty, removing worlds')
                    botSend('['..world..'] spray has empty, removing worlds')
                else
                    while bot:isInWorld() do
                        bot:leaveWorld()
                        sleep(5000)
                    end
                    sleep(1000 * delayLooping)
                end
                table.remove(storageSpray, index)
                goto back
            end
            initialize[world] = scanSeedID()
            botInfo(singleID)
        else
            writeFile(world..' ---STORAGE SPRAY', files.WRONG)
            writeConsole('['..world..'] Storage spray has wrong ID, removing worlds')
            table.remove(storageSpray, index)
            goto back
        end
    else
        writeFile(world..' ---STORAGE SPRAY', files.NUKED)
        writeConsole('['..world..'] Storage spray has NUKED, removing worlds')
        table.remove(storageSpray, index)
        goto back
    end
end

local function takeSeed(worlds, id)
    ::back::
    if #storageSeed == 0 then
        if looping then
            storageSeed = {table.unpack(originalSeed)}
            goto back
        else
            restore()
            bot.custom_status = 'Storage item has empty'
            botInfo(singleID)
            bot:leaveWorld()
            botStatic(messageIdInfo)
            local dialog = 'No world available for collecting seed'
            writeConsole(dialog)
            botSend(dialog)
            if removingBots then
                removeBot()
            end
            if sendNotif then
                notifications(dialog)
            end
            return error(dialog)
        end
    end
    bot.custom_status = 'Take seeds'
    local index = math.random(#storageSeed)
    local world, door = split(storageSeed[index], '[^:]+')[1], split(storageSeed[index], '[^:]+')[2]
    warp(world, door)
    if not nuked then
        if not wrong then
            botStatic(messageIdInfo)
            table.insert(originalSeed, storageSeed[index])
            if scanItem(true) and scanItem(false) then
                for _, ids in pairs(item) do
                    while backpack(ids) < 200 do
                        local pathFound = false
                        for _, obj in pairs(getObjects()) do
                            local targetX, targetY = round(obj.x / 32), math.floor(obj.y / 32)
                            local canFindpath = isCanFindpath(targetX, targetY)
                            if obj.id == ids and canFindpath then
                                bot:findPath(targetX, targetY)
                                sleep(500)
                                bot:collectObject(obj.oid, 3)
                                sleep(500)
                                reposition(world, door, targetX, targetY)
                                pathFound = true
                                break
                            end
                        end
                        if not pathFound then
                            break
                        end
                    end
                end
            else
                if not looping then
                    writeConsole('['..world..'] may has empty, removing worlds')
                    botSend('['..world..'] may has empty, removing worlds')
                else
                    while bot:isInWorld() do
                        bot:leaveWorld()
                        sleep(5000)
                    end
                    sleep(1000 * delayLooping)
                end
                table.remove(storageSeed, index)
                goto back
            end
            initialize[world] = scanSeedID()
            botInfo(singleID)
        else
            writeFile(world..' ---STORAGE SEED', files.WRONG)
            writeConsole('['..world..'] Storage seed has wrong ID, removing worlds')
            table.remove(storageSeed, index)
            goto back
        end
    else
        writeFile(world..' ---STORAGE SEED', files.NUKED)
        writeConsole('['..world..'] Storage seed has NUKED, removing worlds')
        table.remove(storageSeed, index)
        goto back
    end
    if plantID.splice ~= 0 and storage.differentSplice.enabled then
        takeSplice()
    end
    if plantID.spray ~= 0 and storage.differentSpray.enabled then
        takeSpray()
    end
    bot.custom_status = 'Planting'
    if worlds and id then
        warp(worlds, id)
    end
end

local function plant(world, id)
    bot.custom_status = 'Planting'
    for _, tile in pairs(customTiles()) do
        if isPlantable(tile.x, tile.y, true) then
            if ((tile.x > (bot.x + 5)) or (tile.x < (bot.x - 5))) or (tile.y > bot.y) then
                bot:findPath(tile.x, tile.y)
            else
                bot:moveTile(tile.x, tile.y)
                sleep(100)
            end
            reposition(world, id, tile.x, tile.y)
            if plantID.splice ~= 0 then 
                local planted = false
                local items = {plantID.seed}
                while not planted do
                    table.insert(items, plantID.splice)
                    for i, v in pairs(items) do
                        if isPlantable(tile.x, tile.y, false) and canSpray(tile.x, tile.y) then
                            bot:place(tile.x, tile.y, v)
                            sleep(delayPlant)
                            reposition(world, id, tile.x, tile.y)
                        else
                            planted = true
                        end
                    end
                end
            else
                if isPlantable(tile.x, tile.y, true) then
                    bot:place(tile.x, tile.y, plantID.seed)
                    sleep(delayPlant)
                    reposition(world, id, tile.x, tile.y)
                end
            end
            if canSpray(tile.x, tile.y) and plantID.spray ~= 0 then
                bot:place(tile.x, tile.y, plantID.spray)
                sleep(delayPlant)
                reposition(world, id, tile.x, tile.y)
            end
        end
        if not checkItem(true) or not checkItem(false) then
            takeSeed(world, id)
            botStatic(messageIdInfo)
        end
    end
end

if scriptInformation == "Script Plant developed by CRUS4DER | Script Store, Link Discord : https://discord.gg/etM6H4D84Z" and scriptVersion == "0.1" then    
    if fileExists(files.NUKED) then deleteFile(files.NUKED) end
    if fileExists(files.WRONG) then deleteFile(files.WRONG) end
    if fileExists(files.VIEW) then deleteFile(files.VIEW) end

    for i = 0, 53 do
        if i % 2 == 1 then
            table.insert(tileYList, i)
        end
    end
    
    if plantID.splice ~= 0 then
        table.insert(item, plantID.splice)
    end
    
    if plantID.spray ~= 0 then
        table.insert(item, plantID.spray)
    end

    worldFarm = assignWorld(worldList)
    worldSeed = assignWorld(storage)
    worldSplice = assignWorld(storage.differentSplice)
    worldSpray = assignWorld(storage.differentSpray)

    selectWorld(worldList.useFile, worldFarm, farmList)
    selectWorld(storage.useFile, worldSeed, storageSeed)

    if storage.differentSplice.enabled then
        selectWorld(storage.differentSplice.useFile, worldSplice, storageSplice)
    end

    if storage.differentSpray.enabled then 
        selectWorld(storage.differentSpray.useFile, worldSpray, storageSpray)
    end

    if worldList.botPerWorld == 1 then
        spreadWorld(farmList, farmWorld)
    else
        indexBot = getIndex()
        assignBot(farmList, worldList.botPerWorld, farmWorld)
    end

    sleep(bot.index * (1000 * delayExecute))
    createWebhook(bot.index, bots)

    if linkWorldInfo ~= 'x' then
        local assign = createMessageID(linkWorldInfo, 'Creating message for World Info')
        if assign then
            singleID = assign
        end
    end

    reconnect()
    if not checkItem(true) or not checkItem(false) then
        takeSeed()
    end
    
    local info = 0
    for _, farm in pairs(farmWorld) do
        local parts = split(farm, '[^:]+')
        local world, door = parts[1], parts[2]
        bot.custom_status = 'Start planting'
        warp(world, door)
        table.insert(farmInfo, world)
        if not nuked then
            if not wrong then
                timeInfo[world] = os.time()
                botStatic(messageIdInfo)
                botInfo(singleID)
                while scanTiles() ~= 0 do
                    plant(world, door)
                end
                timeInfo[world] = formatUptimeFarm(os.difftime(os.time(), timeInfo[world]))
            else 
                timeInfo[world] = 'WRONG'
                writeFile(farm..' ---FARM', files.WRONG)
                writeConsole('['..world..'] farm has wrong door ID, removing worlds')
            end
        else
            timeInfo[world] = 'NUKED'
            writeFile(farm..' ---FARM', files.NUKED)
            writeConsole('['..world..'] farm has NUKED, removing worlds')
        end
        info = info + 1
        if info % 10 == 0 then
            farmInfo = {}
            timeInfo = {}
        end
    end

    restore()
    bot.custom_status = 'Finished'
    bot:leaveWorld()
    botInfo(singleID)
    botStatic(messageIdInfo)
    local dialog = 'Bot has finished planting all farm worlds'
    writeConsole(dialog)
    botSend(dialog)
    if removingBots then
        removeBot()
    end
    if sendNotif then
        notifications(dialog)
    end
else
    sendNotif = true                                    
    notifications('Buying from reseller? u are idiot people')
end
